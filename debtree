#! /bin/bash
set -e

# debtree version 0.8.1
# Copyright 2007-2009 Frans Pop <elendil@planet.nl>
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.

# Usage: debtree [options] <package name>
#        debtree [options] <package name> <dependency>

# In first case the script produces a dot file for processing with 'dot'.
# Examples: debtree <package> > <package>.dot
#           debtree <package> | dot -Tpng -o <package>.png
#           debtree <package> | dot -Tps | kghostview -
#
# In second case it will list the dependency path(s) from the first
# to the second package.

### LOG FUNCTIONS ###

log() {
	local loglevel=$1
	local message="$2"
	if [ $loglevel -le $verbose ]; then
		echo "$message" >&2
	fi
}
info() {
	local loglevel=$1
	shift
	log $loglevel "I: $@"
}
warn() {
	local loglevel=$1
	shift
	log $loglevel "W: $@"
}
debug() {
	local loglevel=$1
	shift
	log $loglevel "D: $@"
}
error() {
	log 0 "Error: $@"
	exit 1
}

if ! which grep-available grep-aptavail grep-status >/dev/null 2>&1; then
	error "Missing dependency: please install dctrl-tools"
fi

### INITIALIZATION ###

IFS_SV="$IFS"
NL="
"

ARCHES="alpha,amd64,arm,hppa,i386,ia64,m68k,mips,mipsel,powerpc,s390,sparc"
ARCHES="$ARCHES,armel,ppc64,sh,all"

verbose=1
build_dep=""
with_alternatives=1
with_suggests=""
with_recommends=1
with_conflicts=1
with_vconflicts=""
with_provides=1
max_providers=3
with_versions=1
show_installed=""
show_rdeps=""
max_rdeps=5
max_depth=""
no_skip=""
show_all=""
do_rotate=""
do_condense=""
ARCH="$(dpkg --print-architecture)"

while true; do
	case "$1" in
	    "")
		break ;;
	    --build-dep|-b)
		build_dep=1 ;;
	    --no-alternatives)
		with_alternatives="" ;;
	    --no-recommends)
		with_recommends="" ;;
	    --no-conflicts)
		with_conflicts="" ;;
	    --no-provides)
		with_provides="" ;;
	    --max-providers=*)
		max_providers=${1#*=}
		if ! echo $max_providers | grep -q "^[1-9][0-9]*$"; then
			error "invalid value for option 'max-providers'"
		fi ;;
	    --with-suggests|-S)
		with_suggests=1 ;;
	    --versioned-conflicts|-VC)
		with_vconflicts=1 ;;
	    --no-versions)
		with_versions="" ;;
	    --show-installed|-I)
		show_installed=1 ;;
	    --show-rdeps|-R)
		show_rdeps=${show_rdeps:-1} ;;
	    --rdeps-depth=*)
		show_rdeps=${1#*=} ;;
	    --max-rdeps=*)
		max_rdeps=${1#*=} ;;
	    --max-depth=*)
		max_depth=${1#*=}
		if ! echo $max_depth | grep -Eq "^[0-9]+$"; then
			error "invalid value for option 'max-depth'"
		fi ;;
	    --no-skip)
		no_skip=1 ;;
	    --show-all)
		show_all=1 ;;
	    --rotate|-r)
		do_rotate=1 ;;
	    --condense)
		do_condense=1 ;;
	    --arch=*)
		ARCH=${1#*=}
		if ! echo "$ARCHES" | grep -Eq "(^|,)$ARCH(,|$)"; then
			error "invalid value for option 'arch'"
		fi
		if [ "$ARCH" = all ]; then
			ARCH=""
		fi ;;
	    --quiet|-q)
		verbose=0 ;;
	    --verbose|-v)
		[ $verbose -eq 0 ] || verbose=$(($verbose + 1)) ;;
	    -*)
		error "unrecognized argument '$1'"
		;;
	    *)
		if [ -z "$requested_package" ]; then
			requested_package=$1
		elif [ -z "$want_dep" ]; then
			want_dep=$1
		else
			error "invalid number of arguments"
		fi
		;;
	esac
	shift
done

# Don't allow Suggests without Recommends
[ "$with_recommends" ] || with_suggests=""
# Don't allow versioned Conflicts without Conflicts
[ "$with_conflicts" ] || with_vconflicts=""

# Build-dep implies no-suggests and no-alternatives (unless installed packages
# are being displayed); recommends are optional; rdeps are not allowed
if [ "$build_dep" ]; then
	ptype=S
	with_suggests=""
	show_rdeps=""
	[ "$show_installed" ] || with_alternatives=""
	with_provides=""
else
	ptype=B
fi

if [ -z "$requested_package" ]; then
	error "invalid number of arguments"
fi

# ToDo: use configurable colors for everything?
if [ "$show_installed" ]; then
	rdep_color=azure
else
	rdep_color=ivory
fi

### FUNCTIONS ###

full_type() {
	case $1 in
	   PD)	echo Pre-Depends ;;
	   D)	echo Depends ;;
	   R)	echo Recommends ;;
	   S)	echo Suggests ;;
	   C)	echo Conflicts ;;
	esac
}

import_list() {
	local file=$1

	# Ignore blank lines and commas; trim whitespace
	# Move multiple packages on one line to separate lines
	grep -Ev "^[[:space:]]*(#.*)?$" $file | \
		sed -r "s|^[[:space:]]+||	# leading whitespace
			s|[[:space:]]*(#.*)?$||	# trailing whitespace; comments
			s|[[:space:]]+|\n|g"	# split lines
}

grep_avail() {
	local package=$1
	local fields="Pre-Depends,Depends,Recommends,Suggests,Provides,Conflicts"
	local pinfo pr_by
	local RET=1

	if pinfo="$(grep-available -XP $package -s $fields)"; then
		RET=0
	elif pinfo="$(grep-aptavail -XP $package -s $fields)"; then
		RET=0
	else
		# Is this a virtual package?
		pr_by="$(echo $(grep-aptavail -n -s Package \
			 -F Provides --eregex "(^| )$package(,|$)") | \
			 sed "s/ /, /g")"
		if [ "$pr_by" ]; then
			RET=0
			pinfo="Provided-By: $pr_by"
		fi
	fi

	echo "$pinfo"
	return $RET
}

grep_source() {
	local package=$1
	local pinfo
	local RET=0

	pinfo="$(apt-cache showsrc $package | grep -E "^Build-Depends(-Indep)?:")"
	[ "$pinfo" ] || RET=1

	echo "$pinfo"
	return $RET
}

is_installed() {
	local package=$1

	grep-status -XP -s Status $package | grep -q " installed$" || return 1
	return 0
}

get_deps() {
	echo "$1" | grep "^$2:" | sed "s/^[^:]*: //"
}

get_rdeps() {
	local type=$1
	local package=$2
	local parent=$3
	local rdep rdeps

	rdeps=""
	for rdep in $(grep-aptavail -n -s Package -F $(full_type $type) \
				    --eregex "(^| )$package(,| |$)"); do
		# Guard against circular deps
		[ "$rdep" != "$parent" ] || continue

		if [ -z "$show_installed" ] || is_installed $rdep; then
			rdeps=${rdeps:+$rdeps }$rdep
		fi
	done
	echo $rdeps
}


# Convert dependency string a bit for easier parsing:
# - remove space after ","
# - remove space before and after "|"
# - add space after package name if not versioned and no arch conditions
prep_deps() {
	echo "$@" | sed -r "s:, :,:g
			    s: \| :|:g
			    s:([^]) ])(,|\||$):\1 \2:g"
}

check_list() {
	local list
	eval list="\$package_$1"
	echo "$list" | grep -q "^$2$" || return $?
	return 0
}

add_skipped() {
	local package=$1
	if ! check_list skipped "$package"; then
		package_skipped="$package_skipped$package$NL"
	fi
}

# For build dependencies, check if there are architecture conditions
# Any versioned dependency is echo'ed back
# The check is done only if an architecture is specified; if not, the arch
# condition is also echo'ed back and displayed in the graph
check_arch() {
	local dep_type="$1"
	local pkgdep="$2"

	if [ -z "$ARCH" ] || \
	   ([ $dep_type != B ] && [ $dep_type != BI ]); then
		# Echo back full dependency
		echo "$pkgdep"
		return 0
	else
		# Only echo back versioned dependency
		echo "$(echo $pkgdep | sed "s/ *\[.*\] *//")"

		archdep="$(echo $pkgdep | sed "s/ *(.*) *//")"
		if [ -z "$archdep" ]; then
			return 0	# no arch condition
		elif echo "$archdep" | grep -q "!$ARCH[] ]"; then
			return 1	# arch excluded
		elif echo "$archdep" | grep -q "!"; then
			return 0	# there are exclusions (not including arch)
		elif echo "$archdep" | grep -q "[[ ]$ARCH[] ]"; then
			return 0	# arch included
		else
			return 1	# arch not included
		fi
	fi
}

get_prior_OR_dep () {
	local package=$1
	if ! check_list OR_seen "$package"; then
		echo "$OR_dep_list" | grep -E "(:|,)$package(,|$)" | \
			head -n1 | cut -d: -f1
	fi
}

mark_installed() {
	local level=$1
	local package=$2
	local style=filled

	if [ $level -eq 1 ]; then
		style="\"setlinewidth(2),$style\""
	fi
	echo -e "\t\"$package\" [style=${style},fillcolor=honeydew];"
}

mark_rdep() {
	local package=$1
	echo -e "\t\"$package\" [style=filled,fillcolor=$rdep_color];"
}

mark_endpackage() {
	local package=$1
	if [ -z "$(get_prior_OR_dep $package)" ] && \
	   ! check_list rdeps $package; then
		echo -e "\t\"$package\" [shape=diamond];"
		if [ "$show_installed" ] && is_installed $package; then
			mark_installed 0 $package
		fi
	fi
}

print_dot_header() {
	echo "digraph \"$requested_package\" {"
	[ "$do_rotate" ] || echo -e "\trankdir=LR;"
	[ -z "$do_condense" ] || echo -e "\tconcentrate=true;"
	echo -e "\tnode [shape=box];"
}
print_dot_footer() {
	echo "}"
}

print_dot_OR_header() {	
	local type="$1"
	local OR_name="$2"
	local has_inst="$3"

	echo -e "\t$OR_name ["
	echo -e "\t\tshape = \"record\""
	if [ "$has_inst" ]; then
		if [ $type = P ]; then
			echo -e "\t\tstyle = \"rounded,filled\""
		else
			echo -e "\t\tstyle = \"filled\""
		fi
		echo -e "\t\tfillcolor = \"honeydew\""
	elif [ $type = P ]; then
		echo -e "\t\tstyle = \"rounded\""
	fi
	echo -en "\t\tlabel = \""
}
print_dot_OR_footer() {
	echo -e "\"\n\t]"
}

print_dot_OR_main() {
	local package="$1"
	local seen="$2"
	local first=$3

	[ "$first" ] || echo -n " | "
	# Mark packages previously encountered
	if [ "$package" = "..." ]; then
		echo -n "<other> ..."
	elif check_list unknown "$package"; then
		echo -n "<$package> ?$package?"
	elif [ "$seen" = 2 ]; then
		echo -n "<$package> \{$package\}"
	elif [ "$seen" = 1 ]; then
		echo -n "<$package> [$package]"
	else
		echo -n "<$package> $package"
	fi
}

print_alternatives() {
	local type="$1"
	local altrec="$2"
	local package t_altrec first seen

	local OR_name="$(echo "$altrec" | cut -d: -f1)"
	local OR_has_inst="$(echo "$altrec" | cut -d: -f2)"
	local OR_pkgs="$(echo "$altrec" | cut -d: -f3-)"

	first=1
	print_dot_OR_header $type "$OR_name" "$OR_has_inst"
	for package in $(echo $OR_pkgs | sed "s/,/ /g"); do
		# Is this package also part of an earlier set of alternatives?
		seen=""
		if check_list OR_seen "$package"; then
			seen=1
		else
			t_altrec="$(echo "$OR_dep_list" | \
				    grep -E "(:|,)$package(,|$)" | head -n1)"
			if [ $type = D ]; then
				if check_list end "$package" || \
				   check_list ended "$package"; then
					seen=2
				elif [ "$t_altrec" != "$altrec" ]; then
					seen=1
				fi
			else
				if [ "$t_altrec" ]; then
					seen=1
				else
					# Not seen; mark as end package
					seen=2
				fi
			fi
		fi

		print_dot_OR_main "$package" "$seen" "$first"
		first=""
	done
	print_dot_OR_footer
}

print_dot_dependency() {
	local package=$1
	local OR_name=$2
	local dep_package=$3
	local dep_type=$4
	local pkgdep=$5
	local rdep=$6
	local opts=""
	local p_package p_dep_package prior_OR_dep verdep arch_cond

	# Second or later dependency in alternatives: skip unless versioned (see also below)
	# TODO: make this work better if only some of the alternatives have versioned deps
	if [ "$OR_name" ] && ([ -z "$with_versions" ] || [ -z "$pkgdep" ]) && \
	   echo "$OR_dep_list" | grep -Eq "$OR_name:.*,$dep_package(,|$)"; then
		return 0
	fi

	case $dep_type in
	    PD)	opts="${opts:+$opts,}color=purple,style=bold" ;;
	    D)	opts="${opts:+$opts,}color=blue" ;;
	    R)	: ;;
	    S)	opts="${opts:+$opts,}style=dotted" ;;
	    C)	opts="${opts:+$opts,}color=red" ;;
	    B)	opts="${opts:+$opts,}color=darkgoldenrod,style=bold" ;;
	    BI)	opts="${opts:+$opts,}color=goldenrod" ;;
	esac

	if [ "$pkgdep" ]; then
		verdep="$(echo $pkgdep | sed "s/ *\[.*\] *//")"
		arch_cond="$(echo $pkgdep | sed "s/ *(.*) *//")"
		# Always include versions for versioned conflicts
		if [ "$verdep" ] && \
		   ([ "$with_versions" ] || [ $dep_type = C ]); then
			opts="${opts:+$opts,}label=\"$verdep${arch_cond:+\\\\n$arch_cond}\""
		elif [ "$arch_cond" ] && \
		     ([ $dep_type = B ] || [ $dep_type = BI ]); then
			opts="${opts:+$opts,}label=\"$verdep\""
		fi
	fi
	[ -z "$opts" ] || opts=" [$opts]"

	p_package="${prevdep_OR_name:+\"$prevdep_OR_name\":}\"$package\""

	if [ "$OR_name" ]; then
		# Make the link to the alternatives to the group, unless we have
		# to show version or arch condition (see also above)
		if ([ "$with_versions" ] && [ "$verdep" ]) || [ "$arch_cond" ]; then
			p_dep_package="${OR_name:+\"$OR_name\":}\"$dep_package\""
		else
			p_dep_package="\"$OR_name\""
		fi
	else
		# Keep all dependencies on a package with the first alternative
		# For now unless package was previously encountered separately,
		# in which case we use square brackets in the labels (print_dot_OR_main)
		prior_OR_dep="$(get_prior_OR_dep $dep_package)"
		p_dep_package="${prior_OR_dep:+\"$prior_OR_dep\":}\"$dep_package\""
	fi

	echo -e "\t$p_package -> $p_dep_package$opts;"

	# How can "end" packages that are part of an OR be identified?
	# For now, marked by using braces in the labels (see print_dot_OR_main)
	if check_list end "$dep_package" &&  [ -z "$rdep" ] && \
	   [ -z "$OR_name" ] && [ -z "$prior_OR_dep" ] && \
	   ! check_list done "$dep_package"; then
		if [ $dep_type != C ]; then
			debug 4 "Adding '$dep_package' ($dep_type) to ended (list)"
			package_ended="$package_ended$NL$dep_package"
		fi
		package_done="$package_done$NL$dep_package"
	fi
}

print_rdeps_provides() {
	local rdep=$1
	local type=$2
	local package=$3
	local pset=$4
	local pinfo="$5"
	local dep_or deps dset d p cnt regex

	if ! check_list prov_rdeps $rdep; then
		debug 4 "Provider rdeps: $rdep - $type - $package - $pset"
	else
		debug 4 "Provider rdeps: $rdep is already done"
		return 0
	fi
	package_prov_rdeps="$package_prov_rdeps$NL$rdep"

	regex="$(echo "$pset" | sed "s/ /|/")"
	deps=$(get_deps "$pinfo" $(full_type $type))
	IFS=,
	for dep_or in $deps; do
		IFS="$IFS_SV"
		echo "$dep_or" | grep -Eq "(^|\|)($regex)( |$)" || continue

		dset=""
		cnt=0
		IFS="|"
		for d in $dep_or; do
			IFS="$IFS_SV"
			d=${d%% *}
			dset="${dset:+$dset,}$d"
			cnt=$(($cnt + 1))

			# Packages not in the pset are leaf packages
			if ! echo " $pset " | grep -q " $d " && \
			   ! check_list ended $d; then
				debug 4 "Provider rdeps: adding '$d' to ended (list)"
				package_ended="$package_ended$NL$d"
			fi
		done
		[ $cnt -gt 1 ] || return 1

		pdep_set_name="$(echo "$pdep_set_list" | \
			grep ":$dset$" | \
			cut -d: -f1)"
		if [ -z "$pdep_set_name" ]; then
			pdep_set_cnt=$(($pdep_set_cnt + 1))
			pdep_set_name=pds$pdep_set_cnt
			debug 3 "Provider rdeps: new set '$pdep_set_name' - $dset"
			IFS=,
			for p in $dset; do
				IFS="$IFS_SV"
				echo -e "\t\"$pdep_set_name\" -> \"$p\" [style=dotted];"
			done
			echo -e "\t\"$pdep_set_name\" [shape=circle,label=or];"
			pdep_set_list="$pdep_set_list$pdep_set_name:$dset$NL"
		fi
		print_dot_dependency $rdep "" $pdep_set_name $type
	done
	return 0
}

process_deps() {
	local level=$1
	local package=$2
	local deps=$3
	local dep_type=$4
	local dep_tree_in=$5
	local prevdep_OR_name=$6
	local IFS dep dep_or dep_package dep_tree pkgdep
	local OR_name OR_skip OR_pkgs OR_uninst
	local OR_has_skip OR_has_inst OR_has_uninst OR_has_other

	[ $max_depth -ne 0 ] || return 0
	debug 3 "$level - dependencies for '$package' ($dep_type): $deps"

	IFS=,
	for dep in $deps; do
		IFS="$IFS_SV"
		OR_name=""
		OR_skip=""
		OR_pkgs=""
		OR_uninst=""
		OR_has_skip=""
		OR_has_inst=""
		OR_has_uninst=""
		OR_has_other=""

		if [ -z "$want_dep" ] && echo $dep | grep -q "|" && \
		   ([ "$with_alternatives" ] || [ "$show_installed" ]); then
			# Gather information about alternatives
			IFS="|"
			for dep_or in $dep; do
				IFS="$IFS_SV"

				dep_package=${dep_or%% *}
				if check_list skip "$dep_package"; then
					add_skipped "$dep_package"
					OR_has_skip=1
					# Account for installation status
					if [ "$show_installed" ]; then
						if is_installed $dep_package; then
							OR_has_inst=1
						else
							OR_has_uninst=1
						fi
					fi
					continue
				fi

				if [ -z "$show_installed" ]; then
					OR_pkgs="${OR_pkgs:+$OR_pkgs,}$dep_package"
				elif is_installed $dep_package; then
					OR_pkgs="${OR_pkgs:+$OR_pkgs,}$dep_package"
					OR_has_inst=1
				else
					OR_uninst="${OR_uninst:+$OR_uninst,}$dep_package"
					OR_has_uninst=1
				fi
			done
			# If none of the alternatives is installed, show them all
			if [ "$show_installed" ] && [ -z "$OR_has_inst" ]; then
				OR_pkgs="$OR_uninst"
				OR_has_uninst=""
			fi
			[ "$OR_pkgs" ] || OR_skip=1

			# Create alternative dependency "records" for dot graph
			if [ -z "$OR_skip" ] && [ "$with_alternatives" ]; then
				OR_has_other=$OR_has_skip$OR_has_uninst

				# Check if we already have these (exact) alternatives
				OR_name="$(echo "$OR_dep_list" | \
					grep ":$OR_pkgs${OR_has_other:+,...}$" | \
					cut -d: -f1)"
				if [ -z "$OR_name" ]; then
					OR_dep_cnt=$(($OR_dep_cnt + 1))
					OR_name=alt$OR_dep_cnt

					debug 3 "Alternatives: new set '$OR_name' - $OR_pkgs"
					for dep_package in $(echo $OR_pkgs | sed "s/,/ /g"); do
						# Has this dependency already been
						# processed as a separate package?
						if check_list done "$dep_package" && \
						   ! echo "$OR_dep_list" | grep -Eq "(:|,)$dep_package(,|$)" && \
						   ! check_list OR_seen "$dep_package"; then
							package_OR_seen="$package_OR_seen$NL$dep_package"
						fi
					done

					OR_dep_list="$OR_dep_list$OR_name:$OR_has_inst:$OR_pkgs${OR_has_other:+,...}$NL"
				else
					debug 3 "Alternatives: matches existing set '$OR_name'"
				fi
			fi
		fi

		if [ "$OR_skip" ]; then
			debug 3 "Alternatives: skipping ('$dep')"
			continue
		fi

		IFS="|"
		for dep_or in $dep; do
			IFS="$IFS_SV"
			dep_tree=$dep_tree_in

			dep_package=${dep_or%% *}
			debug 3 "Processing dependency '$package'->'$dep_package'"

			if [ "$show_installed" ] && [ "$OR_name" ] && \
			   ! echo "$OR_pkgs" | grep -Eq "(^|,)$dep_package(,|$)"; then
				continue
			fi

			# Check for arch-conditioned build-dependencies
			# Note: for build dependencies pkgdep can include arch-conditions
			if ! pkgdep=$(check_arch $dep_type "${dep_or#* }"); then
				info 1 "Build dependency ($dep_type) on '$dep_package' not for $ARCH"
				continue
			fi

			dep_tree="$dep_tree -> $dep_package ($dep_type)"

			if [ -z "$want_dep" ]; then
				if check_list skip "$dep_package"; then
					add_skipped "$dep_package"
					continue
				elif [ $dep_type = C ] && \
				     [ -z "$with_vconflicts" ] && [ "$pkgdep" ]; then
					# Skip only unversioned conflicts
					continue
				fi
				print_dot_dependency $package "$OR_name" \
					$dep_package $dep_type "$pkgdep"
			elif [ "$dep_package" = "$want_dep" ]; then
				echo "$dep_tree"
				continue
			fi

			if check_list done "$dep_package" ||
			   ([ -z "$want_dep" ] &&
			    check_list end "$dep_package"); then
				:
			else
				# Recurse through dependencies, except for Suggests
				# and Conflicts
				case $dep_type in
				    S)
					if ! check_list done "$dep_package"; then
						debug 4 "Adding '$dep_package' ($dep_type) to ended"
						package_ended="$package_ended$NL$dep_package"
						package_leaf="$package_leaf$NL$dep_package"
					fi ;;
				    C)
					if ! check_list done "$dep_package"; then
						package_leaf="$package_leaf$NL$dep_package"
					fi ;;
				    *)
					if [ -z "$max_depth" ] || [ $level -lt $max_depth ]; then
						process_package $(($level + 1)) $dep_package \
							"$dep_tree" "$OR_name" ""
					else
						debug 4 "Adding '$dep_package' ($dep_type) to ended (max)"
						package_ended="$package_ended$NL$dep_package"
					fi ;;
				esac
			fi

			[ "$with_alternatives" ] || break
		done
	done
}

process_virtual() {
	local level=$1
	local package=$2
	local providers=$3
	local dep_tree=$4
	local prevdep_OR_name=$5
	local ptype=$6
	local prior_OR_dep p_package p_provider prov_cnt
	local OR_pkgs OR_name OR_has_inst OR_has_uninst OR_uninst

	if [ $level -eq 1 ]; then
		debug 3 "$level - '$providers' provides '$package'"
	else
		debug 3 "$level - '$package' provided by: $providers"
	fi

	p_package="${prevdep_OR_name:+\"$prevdep_OR_name\":}\"$package\""

	prov_cnt=$(echo "$providers" | sed "s/,/\n/g" | wc -l)
	if [ $prov_cnt -eq 1 ]; then
		provider=${providers%% *}
		if [ $level -ne 1 ] && check_list skip "$provider"; then
			add_skipped "$provider"
		else
			prior_OR_dep="$(get_prior_OR_dep $provider)"
			p_provider="${prior_OR_dep:+\"$prior_OR_dep\":}\"$provider\""
			if [ $level -eq 1 ] && [ -z "$show_rdeps" ]; then
				echo -e "\t$p_provider -> $p_package [arrowhead=inv,color=green];"
			else
				echo -e "\t$p_package -> $p_provider [dir=back,arrowtail=inv,color=green];"
			fi

			if check_list end "$provider" && \
			   [ -z "$prior_OR_dep" ] && \
			   ! check_list done "$provider"; then
				debug 4 "Adding '$dep_package' (provides) to ended (list)"
				package_ended="$package_ended$NL$provider"
				package_done="$package_done$NL$provider"
			fi

			# Recurse to get dependencies for providing package
			dep_tree="$dep_tree <- $provider"
			if ! check_list done "$provider" && [ ! "$ptype" = L ]; then
				process_package $(($level + 1)) $provider "$dep_tree" "" ""
			fi
		fi
	else
		# Note: if there are multiple providing packages, we do
		# not recurse into them!
		IFS=,
		for provider in $providers; do
			IFS="$IFS_SV"
			provider=${provider%% *}
			if [ "$show_installed" ]; then
				if is_installed $provider; then
					OR_pkgs="${OR_pkgs:+$OR_pkgs,}$provider"
					OR_has_inst=1
				else
					OR_uninst="${OR_uninst:+$OR_uninst,}$provider"
					OR_has_uninst=1
				fi
			else
				OR_pkgs="${OR_pkgs:+$OR_pkgs,}$provider"
			fi
		done
		if [ "$show_installed" ] && [ -z "$OR_pkgs" ]; then
			# If none of the alternatives is installed, show them all
			OR_pkgs="$OR_uninst"
			OR_has_uninst=""
		fi

		# Only show multiple providing packages if there are $max_providers
		# or less, or when restricted to installed packages
		if [ $prov_cnt -le $max_providers ] || \
		   ([ "$show_installed" ] && [ "$OR_has_inst" ]); then
			# Check if we already have these (exact) alternative providers
			OR_name="$(echo "$OR_virt_list" | \
				grep ":$OR_pkgs${OR_has_uninst:+,...}$" | cut -d: -f1)"
			if [ -z "$OR_name" ]; then
				OR_virt_cnt=$(($OR_virt_cnt + 1))
				OR_name=virt$OR_virt_cnt

				debug 3 "Providers: new set '$OR_name' - $OR_pkgs"
				OR_virt_list="$OR_virt_list$OR_name:$OR_has_inst:$OR_pkgs${OR_has_uninst:+,...}$NL"
			else
				debug 3 "Providers: matches existing set '$OR_name'"
			fi

			# Print the arrow now; the record itself is printed later
			echo -e "\t$p_package -> $OR_name [dir=back,arrowtail=inv,color=green];"
		else
			echo -e "\t$p_package -> \"Pr-$package\" [label=\"-$prov_cnt-\",dir=back,arrowtail=inv,color=green];"
			echo -e "\t\"Pr-$package\" [label=\"...\",style=rounded];"
		fi
	fi

	# Green arrow sufficiently identifies virtual package that is part of alternatives
	if [ -z "$prevdep_OR_name" ] || check_list OR_seen "$package"; then
		echo -e "\t\"$package\" [shape=octagon];"
	fi
}

process_missing() {
	local package=$1

	local prior_OR_dep="$(get_prior_OR_dep $package)"
	if [ -z "$prior_OR_dep" ]; then
		echo -e "\t\"$package\" [style=filled,fillcolor=oldlace];"
	else
		package_unknown="$package_unknown$package$NL"
	fi
}

find_rdeps() {
	local level=$1
	local package=$2
	local parent=$3
	local provides=$4
	local type rdeps recurse_rdeps cnt opts pinfo
	local has_max=""

	info 2 "Level $level: processing reverse dependencies for $package"
	package_rdeps="$package_rdeps$NL$package"

	recurse_rdeps=""
	for type in PD D ${with_recommends:+R}; do
		rdeps=$(get_rdeps $type $package $parent)
		cnt=$(echo "$rdeps" | wc -w)
		if [ $cnt -gt 0 ]; then
			debug 4 "$level - ${show_installed:+installed }$type rdeps for '$package' ($cnt): $rdeps"
		fi

		if [ $level -lt -1 ] && [ $cnt -gt $max_rdeps ]; then
			case $type in
			   PD)	opts="color=purple,style=bold" ;;
			   D)	opts="color=blue" ;;
			   R)	opts="" ;;
			esac
			opts=" [label=\"-$cnt-\",$opts]"
			echo -e "\t\"Rdep-$package\" -> \"$package\" $opts;"
			has_max=1
			continue
		fi

		recurse_rdeps=${recurse_rdeps:+$recurse_rdeps }$rdeps
		for rdep in $rdeps; do
			pinfo="$(grep_avail $rdep)" || RET=$?
			pinfo="$(prep_deps "$pinfo")"
			if [ "$provides" ] && \
			   print_rdeps_provides $rdep $type $package "$parent $provides" "$pinfo"; then
				continue
			fi

			if ! check_list done $rdep; then
				debug 4 "$level - adding reverse dependency '$rdep'->'$package'"
				print_dot_dependency $rdep "" $package $type "" 1
			else
				debug 4 "$level - package '$rdep' is already done"
			fi
		done
	done

	for rdep in $recurse_rdeps; do
		if ! check_list rdeps $rdep; then
			if ! check_list done $rdep; then
				mark_rdep $rdep
			fi
			if [ $level -eq -1 ]; then
				find_rdeps $(($level -1)) $rdep $package
			elif [ $level -gt -$show_rdeps ]; then
				find_rdeps $(($level -1)) $rdep
			fi
		fi
	done

	if [ "$has_max" ]; then
		echo -e "\t\"Rdep-$package\" [label=\"...\",style=\"rounded,filled\",fillcolor=$rdep_color];"
	fi
}

process_package() {
	local level=$1
	local package=$2
	local dep_tree="$3"
	local prevdep_OR_name="$4"
	local ptype="$5"
	local p pinfo providers deps

	info 2 "Level $level: processing $package ${ptype:+($ptype)}"

	if [ "$ptype" != L ] && check_list ended $package; then
		debug 4 "Removing '$dep_package' from ended"
		package_ended="$(echo "$package_ended" | grep -v "^$package$")"
	fi

	RET=0
	if [ "$ptype" = S ]; then
		pinfo="$(grep_source $package)" || RET=$?
	else
		pinfo="$(grep_avail $package)" || RET=$?
	fi

	if [ "$ptype" = B ] || [ "$ptype" = S ]; then
		if [ $RET -eq 0 ]; then
			[ "$want_dep" ] || print_dot_header
		else
			error "no dependency info found for '$package'"
		fi
	else
		if [ -z "$want_dep" ] && [ $RET -ne 0 ]; then
			process_missing $package
		fi
	fi
	pinfo="$(prep_deps "$pinfo")"

	# Mark as done now to prevent recursion loops
	package_done="$package_done$NL$package"

	# Not sure if we should do this or not when showing dependency paths
	providers=$(get_deps "$pinfo" Provided-By)
	if [ -z "$want_dep" ] && [ "$providers" ]; then
		# For leaf packages we need to check if it was an alternative
		if [ "$ptype" = L ]; then
			prevdep_OR_name="$(get_prior_OR_dep $package)"
		fi

		process_virtual $level $package \
			"$providers" "$dep_tree" "$prevdep_OR_name" "$ptype"
	fi

	[ ! "$ptype" = L ] || return 0

	if [ "$ptype" = S ]; then
		deps=$(get_deps "$pinfo" Build-Depends)
		process_deps $level $package "$deps" B "" ""
		deps=$(get_deps "$pinfo" Build-Depends-Indep)
		process_deps $level $package "$deps" BI "" ""
	fi

	deps=$(get_deps "$pinfo" Pre-Depends)
	process_deps $level $package "$deps" PD "$dep_tree" "$prevdep_OR_name"

	deps=$(get_deps "$pinfo" Depends)
	process_deps $level $package "$deps" D "$dep_tree" "$prevdep_OR_name"

	if [ "$with_recommends" ]; then
		deps=$(get_deps "$pinfo" Recommends)
		process_deps $level $package "$deps" R "$dep_tree" "$prevdep_OR_name"
	fi

	if [ "$with_suggests" ]; then
		deps=$(get_deps "$pinfo" Suggests)
		process_deps $level $package "$deps" S "$dep_tree" "$prevdep_OR_name"
	fi

	if [ "$with_conflicts" ]; then
		deps=$(get_deps "$pinfo" Conflicts)
		process_deps $level $package "$deps" C "$dep_tree" "$prevdep_OR_name"
	fi

	# Provides and reverse dependencies for the requested package
	if [ -z "$want_dep" ] && [ $level -eq 1 ] &&
	   ([ "$with_provides" ] || [ "$show_rdeps" ]); then
		provides=$(get_deps "$pinfo" Provides | sed "s/ //g; s/,/ /g")
		if [ -z "$with_provides" ] || [ -z "$provides" ]; then
			if [ "$show_rdeps" ]; then
				debug 4 "Find rdeps for the package"
				find_rdeps -1 $package
			fi
		elif [ "$provides" ]; then
			# Virtual packages
			for provided in $provides; do
				process_virtual $level $provided $package "$dep_tree" "" L
			done
			# Installed reverse dependencies for the package and its provides
			if [ "$show_rdeps" ]; then
				debug 4 "Find rdeps for the package & its provides"
				for p in $package $provides; do
					find_rdeps -1 $p $package "$provides"
				done
			fi
		fi
	fi

	if [ "$show_installed" ] && is_installed $package && \
	   [ -z "$(get_prior_OR_dep $package)" ]; then
		mark_installed $level $package
	elif [ $level -eq 1 ]; then
		echo -e "\t\"$package\" [style=\"setlinewidth(2)\"]"
	fi

	debug 3 "Level $level: processing $package ${ptype:+($ptype)} - done"
}

### MAINLINE ###

package_skip=""
package_skipped=""
package_end=""
package_ended=""
package_done=""
package_leaf=""
package_unknown=""
package_OR_seen=""
OR_dep_cnt=0
OR_dep_list=""
OR_virt_cnt=0
OR_virt_list=""
pdep_set_list=""
pdep_set_cnt=0

# Import lists to limit processing:
# - "skip" packages are completely ignored: nothing is displayed
# - "end" packages are displayed and marked as such, but we don't recurse
#   to determine their dependencies
if [ -z "$show_all" ]; then
	for file in ~/.debtree/skiplist /etc/debtree/skiplist; do
		if [ -r $file ]; then
			info 3 "Using list of 'skip' packages from $file"
			package_skip="$(import_list $file)"
			break
		fi
	done
	for file in ~/.debtree/endlist /etc/debtree/endlist; do
		if [ -r $file ]; then
			info 3 "Using list of 'end' packages from $file"
			package_end="$(import_list $file)"
			break
		fi
	done
fi
if [ "$no_skip" ] && [ "$package_skip" ]; then
	# Change skip packages to end packages
	package_end="${package_end:+$package_end$NL}$package_skip"
	package_skip=""
fi

# If a dependency path is asked for, check if the second package exists
if [ "$want_dep" ]; then
	if ! grep_avail $want_dep >/dev/null; then
		error "no dependency info found for '$want_dep'"
	fi
fi

# ptype B/S indicates "start" binary/source package
process_package 1 $requested_package $requested_package "" $ptype

# For packages we did not yet recurse through, check if they are virtual
# packages as we want to show the providing package(s)
info 2 "Processing leaf packages"
for dep_package in $package_leaf; do
	if ! check_list done "$dep_package"; then
		process_package 0 $dep_package "" "" L
	fi
done

if [ -z "$want_dep" ]; then
	info 2 "Final processing for graph"
	# Print record definitions for alternatives
	IFS="$NL"
	for altrec in $OR_dep_list; do
		IFS="$IFS_SV"
		print_alternatives D "$altrec"
	done

	# Print record definitions for alternative provides
	IFS="$NL"
	for altrec in $OR_virt_list; do
		IFS="$IFS_SV"
		print_alternatives P "$altrec"
	done
	IFS="$IFS_SV"

	# Set shape to diamond for packages whose dependencies we did not
	# recurse into
	for package in $package_ended; do
		mark_endpackage $package
	done

	print_dot_footer
fi


if [ "$package_skipped" ]; then
	info 1 "The following dependencies have been excluded from the graph (skipped):"
	info 1 "$(echo $package_skipped)"
	# Also list excluded packages as comments in the output
	echo "// Excluded dependencies:"
	echo "// $(echo $package_skipped)"
fi
