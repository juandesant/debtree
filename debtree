#! /bin/bash
set -e

# debtree version 0.7.1
# Copyright: Frans Pop <elendil@planet.nl>, 2007
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.

# Usage: debtree [options] <package name>
#        debtree [-S] <package name> <dependency>

# In first case script produces a dot file for processing with 'dot'.
# Examples: debtree <package> > <package>.dot
#           debtree <package> | dot -Tpng -o <package>.png
#           debtree <package> | dot -Tps | kghostview -
#
# In second case it will list the dependency path(s) from the first
# to the second package.

# NOTES
# - Output looks OK in big lines, but needs verification in detail
# - Suggests are not recursed; doing a full tree would lead to insane trees
#   in almost all situations
# - Conflicts are not recursed; what would be the point

# TODO
# - the dependency patch usage needs testing and update; concentrated on
#   getting dependency tree (graph) correct
# - add "usage" function and --version and --help options
# - this code really needs a testsuite as regressions are many and subtle;
#   comparing the .dot output with expected should be trivial if a fixed
#   status database is used
# - rewrite in e.g. C++; existing 'apt-cache dotty' code can be used as
#   staring point
# - automatic limiting
# - automatically split graphs over multiple subgraphs (which dot will place
#   on separate pages)
# - identify transitional packages

### LOG FUNCTIONS ###

log() {
	local loglevel=$1
	local message="$2"
	if [ $loglevel -le $verbose ]; then
		echo "$message" >&2
	fi
}
info() {
	local loglevel=$1
	shift
	log $loglevel "I: $@"
}
warn() {
	local loglevel=$1
	shift
	log $loglevel "W: $@"
}
debug() {
	local loglevel=$1
	shift
	log $loglevel "D: $@"
}
error() {
	log 0 "Error: $@"
	exit 1
}

if ! which grep-available grep-aptavail grep-status >/dev/null 2>&1; then
	error "Missing dependency: please install dctrl-tools"
fi

### INITIALIZATION ###

IFS_SV="$IFS"
NL="
"

ARCHES="alpha,amd64,arm,hppa,i386,ia64,m68k,mips,mipsel,powerpc,s390,sparc"
ARCHES="$ARCHES,armel,ppc64,sh,all"

verbose=1
build_dep=""
with_alternatives=1
with_suggests=""
with_recommends=1
with_conflicts=1
with_vconflicts=""
with_versions=1
show_installed=""
max_depth=""
no_skip=""
show_all=""
do_rotate=""
do_condense=""
ARCH="$(dpkg --print-architecture)"

while true; do
	case "$1" in
	    "")
		break ;;
	    --build-dep|-b)
		build_dep=1 ;;
	    --no-alternatives)
		with_alternatives="" ;;
	    --no-recommends)
		with_recommends="" ;;
	    --no-conflicts)
		with_conflicts="" ;;
	    --with-suggests|-S)
		with_suggests=1 ;;
	    --versioned-conflicts|-VC)
		with_vconflicts=1 ;;
	    --no-versions)
		with_versions="" ;;
	    --show-installed|-I)
		show_installed=1 ;;
	    --max-depth=*)
		max_depth=${1#*=}
		if ! echo $max_depth | grep -q "^[1-9][0-9]*$"; then
			error "invalid value for option 'max-depth'"
		fi ;;
	    --no-skip)
		no_skip=1 ;;
	    --show-all)
		show_all=1 ;;
	    --rotate|-r)
		do_rotate=1 ;;
	    --condense)
		do_condense=1 ;;
	    --arch=*)
		ARCH=${1#*=}
		if ! echo "$ARCHES" | grep -Eq "(^|,)$ARCH(,|$)"; then
			error "invalid value for option 'arch'"
		fi
		if [ "$ARCH" = all ]; then
			ARCH=""
		fi ;;
	    --quiet|-q)
		verbose=0 ;;
	    --verbose|-v)
		[ $verbose -eq 0 ] || verbose=$(($verbose + 1)) ;;
	    -*)
		error "unrecognized argument '$1'"
		;;
	    *)
		if [ -z "$requested_package" ]; then
			requested_package=$1
		elif [ -z "$want_dep" ]; then
			want_dep=$1
		else
			error "invalid number of arguments"
		fi
		;;
	esac
	shift
done

# Don't allow Suggests without Recommends
[ "$with_recommends" ] || with_suggests=""
# Don't allow versioned Conflicts without Conflicts
[ "$with_conflicts" ] || with_vconflicts=""

# Build-dep implies no-suggests and no-alternatives (unless installed packages
# are being displayed; recommends are optional
if [ "$build_dep" ]; then
	ptype=S
	with_suggests=""
	[ "$show_installed" ] || with_alternatives=""
else
	ptype=B
fi

if [ -z "$requested_package" ]; then
	error "invalid number of arguments"
fi

### FUNCTIONS ###

import_list() {
	local file=$1

	# Ignore blank lines and commas; trim whitespace
	# Move multiple packages on one line to separate lines
	grep -Ev "^[[:space:]]*(#.*)?$" $file | \
		sed -r "s|^[[:space:]]+||	# leading whitespace
			s|[[:space:]]*(#.*)?$||	# trailing whitespace; comments
			s|[[:space:]]+|\n|g"	# split lines
}

grep_avail() {
	local package=$1
	local fields="Pre-Depends,Depends,Recommends,Suggests,Provides,Conflicts"
	local pinfo pr_by
	local RET=1

	if pinfo="$(grep-available -XP $package -s $fields)"; then
		RET=0
	elif pinfo="$(grep-aptavail -XP $package -s $fields)"; then
		RET=0
	else
		# Is this a pseudo package?
		pr_by="$(echo $(grep-aptavail -n -s Package \
			 -F Provides --eregex "(^| )$package(,|$)") | \
			 sed "s/ /, /g")"
		if [ "$pr_by" ]; then
			RET=0
			pinfo="Provided-By: $pr_by"
		fi
	fi

	echo "$pinfo"
	return $RET
}

grep_source() {
	local package=$1
	local pinfo
	local RET=0

	pinfo="$(apt-cache showsrc $package | grep -E "^Build-Depends(-Indep)?:")"
	[ "$pinfo" ] || RET=1

	echo "$pinfo"
	return $RET
}

is_installed() {
	local package=$1

	grep-status -XP -s Status $package | grep -q " installed$" || return 1
	return 0
}

get_deps() {
	echo "$1" | grep "^$2:" | sed "s/^[^:]*: //"
}


# Convert dependency string a bit for easier parsing:
# - remove space after ","
# - remove space before and after "|"
# - add space after package name if not versioned and no arch conditions
prep_deps() {
	echo "$@" | sed -r "s:, :,:g
			    s: \| :|:g
			    s:([^]) ])(,|\||$):\1 \2:g"
}

check_list() {
	local list
	eval list="\$package_$1"
	echo "$list" | grep -q "^$2$" || return $?
	return 0
}

# For build dependencies, check if there are architecture conditions
# Any versioned dependency is echo'ed back
# The check is done only if an architecture is specified; if not, the arch
# condition is also echo'ed back and displayed in the graph
check_arch() {
	local dep_type="$1"
	local pkgdep="$2"

	if [ -z "$ARCH" ] ||
	   ([ "$dep_type" != B ] && [ "$dep_type" != BI ]); then
		# Echo back full dependency
		echo "$pkgdep"
		return 0
	else
		# Only echo back versioned dependency
		echo "$(echo $pkgdep | sed "s/ *\[.*\] *//")"

		archdep="$(echo $pkgdep | sed "s/ *(.*) *//")"
		if [ -z "$archdep" ]; then
			return 0	# no arch condition
		elif echo "$archdep" | grep -q "!$ARCH[] ]"; then
			return 1	# arch excluded
		elif echo "$archdep" | grep -q "!"; then
			return 0	# there are exclusions (not including arch)
		elif echo "$archdep" | grep -q "[[ ]$ARCH[] ]"; then
			return 0	# arch included
		else
			return 1	# arch not included
		fi
	fi
}

get_prior_OR_name () {
	local package=$1
	if ! check_list OR_seen "$package"; then
		echo "$OR_list" | grep -E "(:|,)$package(,|$)" | \
			head -n1 | cut -d: -f1
	fi
}

mark_installed() {
	local package=$1
	echo -e "\t\"$package\" [style=filled,fillcolor=honeydew];"
}

mark_endpackage() {
	local package=$1
	if [ -z "$(get_prior_OR_name $package)" ]; then
		echo -e "\t\"$package\" [shape = diamond];"
		if [ "$show_installed" ] && is_installed $package; then
			mark_installed $package
		fi
	fi
}

print_dot_header() {
	echo "digraph \"$requested_package\" {"
	[ "$do_rotate" ] || echo -e "\trankdir=LR;"
	[ -z "$do_condense" ] || echo -e "\tconcentrate=true;"
	echo -e "\tnode [shape=box];"
}
print_dot_footer() {
	echo "}"
}

print_dot_OR_header() {	
	local OR_name="$1"
	local has_inst="$2"

	echo -e "\t$OR_name ["
	echo -e "\t\tshape = \"record\""
	if [ "$has_inst" ]; then
		echo -e "\t\tstyle = \"filled\""
		echo -e "\t\tfillcolor = \"honeydew\""
	fi
	echo -en "\t\tlabel = \""
}
print_dot_OR_footer() {
	echo -e "\"\n\t]"
}

print_dot_OR_main() {
	local package="$1"
	local seen="$2"
	local first=$3

	[ "$first" ] || echo -n " | "
	# Mark packages previously encountered
	if [ "$package" = "..." ]; then
		echo -n "<other> ..."
	elif check_list unknown "$package"; then
		echo -n "<$package> ?$package?"
	elif check_list skip "$package"; then
		echo -n "<$package> ($package)"
	elif check_list ended "$package"; then
		echo -n "<$package> \{$package\}"
	elif [ "$seen" ] || check_list OR_seen "$package"; then
		echo -n "<$package> [$package]"
	else
		echo -n "<$package> $package"
	fi
}

print_alternatives() {
	local altrec="$1"
	local package t_altrec first seen

	local OR_name="$(echo "$altrec" | cut -d: -f1)"
	local OR_has_inst="$(echo "$altrec" | cut -d: -f2)"
	local OR_pkgs="$(echo "$altrec" | cut -d: -f3-)"

	first="1"
	print_dot_OR_header "$OR_name" "$OR_has_inst"
	for package in $(echo $OR_pkgs | sed "s/,/ /g"); do
		# Is this package also part of an earlier set of alternatives?
		seen=""
		t_altrec="$(echo "$OR_list" | \
			    grep -E "(:|,)$package(,|$)" | head -n1)"
		[ "$t_altrec" = "$altrec" ] || seen="1"

		print_dot_OR_main "$package" "$seen" "$first"
		first=""
	done
	print_dot_OR_footer
}

print_dot_dependency() {
	local package=$1
	local OR_name=$2
	local dep_package=$3
	local dep_type=$4
	local pkgdep=$5
	local opts=""
	local p_package p_dep_package prior_OR_name verdep arch_cond

	# Second or later dependency in alternatives: skip unless versioned (see also below)
	# TODO: make this work better if only some of the alternatives have versioned deps
	if [ "$OR_name" ] && ([ -z "$with_versions" ] || [ -z "$pkgdep" ]) && \
	   echo "$OR_list" | grep -Eq "$OR_name:.*,$dep_package(,|$)"; then
		return 0
	fi

	case $dep_type in
	    PD)	opts="${opts:+$opts,}color=purple,style=bold" ;;
	    D)	opts="${opts:+$opts,}color=blue" ;;
	    R)	: ;;
	    S)	opts="${opts:+$opts,}style=dotted" ;;
	    C)	opts="${opts:+$opts,}color=red" ;;
	    B)	opts="${opts:+$opts,}color=darkgoldenrod,style=bold" ;;
	    BI)	opts="${opts:+$opts,}color=goldenrod" ;;
	esac

	if [ "$pkgdep" ]; then
		verdep="$(echo $pkgdep | sed "s/ *\[.*\] *//")"
		arch_cond="$(echo $pkgdep | sed "s/ *(.*) *//")"
		# Always include versions for versioned conflicts
		if [ "$verdep" ] && \
		   ([ "$with_versions" ] || [ "$dep_type" = C ]); then
			opts="${opts:+$opts,}label=\"$verdep${arch_cond:+\\\\n$arch_cond}\""
		elif [ "$arch_cond" ] && \
		     ([ "$dep_type" = B ] || [ "$dep_type" = BI ]); then
			opts="${opts:+$opts,}label=\"$verdep\""
		fi
	fi
	[ -z "$opts" ] || opts=" [$opts]"

	p_package="${predep_OR_name:+\"$predep_OR_name\":}\"$package\""

	if [ "$OR_name" ]; then
		# Make the link to the alternatives to the group, unless we have
		# to show version or arch condition (see also above)
		if ([ "$with_versions" ] && [ "$verdep" ]) || [ "$arch_cond" ]; then
			p_dep_package="${OR_name:+\"$OR_name\":}\"$dep_package\""
		else
			p_dep_package="\"$OR_name\""
		fi
	else
		# Keep all dependencies on a package with the first alternative
		# For now unless package was previously encountered separately,
		# in which case we use square brackets in the labels (print_dot_OR_main)
		prior_OR_name="$(get_prior_OR_name $dep_package)"
		p_dep_package="${prior_OR_name:+\"$prior_OR_name\":}\"$dep_package\""
	fi

	echo -e "\t$p_package -> $p_dep_package$opts;"

	# How can "end" packages that are part of an OR be identified?
	# For now, marked by using braces in the labels (see print_dot_OR_main)
	if check_list end "$dep_package" && \
	   [ -z "$OR_name" ] && [ -z "$prior_OR_name" ] && \
	   ! check_list done "$dep_package"; then
		if [ "$dep_type" != C ]; then
			debug 4 "Adding '$dep_package' ($dep_type) to ended (list)"
			package_ended="$package_ended$NL$dep_package"
		fi
		package_done="$package_done$NL$dep_package"
	fi
}

process_deps() {
	local level=$1
	local package=$2
	local deps=$3
	local dep_type=$4
	local dep_tree_in=$5
	local predep_OR_name=$6
	local IFS dep dep_or dep_package dep_tree pkgdep
	local OR_pkgs OR_name OR_has_inst OR_has_uninst OR_uninst

	debug 3 "$level - dependencies for '$package' ($dep_type): $deps"

	IFS=,
	for dep in $deps; do
		IFS="$IFS_SV"
		OR_name=""
		OR_pkgs=""
		OR_uninst=""
		OR_has_inst=""
		OR_has_uninst=""

		if [ -z "$want_dep" ] && echo $dep | grep -q "|" && \
		   ([ "$with_alternatives" ] || [ "$show_installed" ]); then
			# Gather information about alternatives
			IFS="|"
			for dep_or in $dep; do
				IFS="$IFS_SV"

				dep_package=${dep_or%% *}
				if [ "$show_installed" ]; then
					if is_installed $dep_package; then
						OR_pkgs="${OR_pkgs:+$OR_pkgs,}$dep_package"
						OR_has_inst=1
					else
						OR_uninst="${OR_uninst:+$OR_uninst,}$dep_package"
						OR_has_uninst=1
					fi
				else
					OR_pkgs="${OR_pkgs:+$OR_pkgs,}$dep_package"
				fi
			done
			if [ "$show_installed" ] && [ -z "$OR_pkgs" ]; then
				# If none of the alternatives is installed, show them all
				OR_pkgs="$OR_uninst"
				OR_has_uninst=""
			fi

			# Create alternative dependency "records" for dot graph
			if [ "$with_alternatives" ]; then
				# Check if we already have these (exact) alternatives
				OR_name="$(echo "$OR_list" | grep ":$OR_pkgs${OR_has_uninst:+,...}$" | cut -d: -f1)"
				if [ -z "$OR_name" ]; then
					OR_cnt=$(($OR_cnt + 1))
					OR_name=alt$OR_cnt

					debug 3 "Alternatives: new set '$OR_name' - $OR_pkgs"
					for dep_package in $(echo $OR_pkgs | sed "s/,/ /g"); do
						# Has this dependency already been processed as
						# a separate package?
						if check_list done "$dep_package" && \
						   ! echo "$OR_list" | grep -Eq "(:|,)$dep_package(,|$)" && \
						   ! check_list OR_seen "$dep_package"; then
							package_OR_seen="$package_OR_seen$NL$dep_package"
						fi
					done

					OR_list="$OR_list$OR_name:$OR_has_inst:$OR_pkgs${OR_has_uninst:+,...}$NL"
				else
					debug 3 "Alternatives: matches existing set '$OR_name'"
				fi
			fi
		fi

		IFS="|"
		for dep_or in $dep; do
			IFS="$IFS_SV"
			dep_tree=$dep_tree_in

			dep_package=${dep_or%% *}
			debug 3 "Processing dependency '$package'->'$dep_package'"

			if [ "$show_installed" ] && [ "$OR_name" ] && \
			   ! echo "$OR_pkgs" | grep -Eq "(^|,)$dep_package(,|$)"; then
				continue
			fi

			# Check for arch-conditioned build-dependencies
			# Note: for build dependencies pkgdep can include arch-conditions
			if ! pkgdep=$(check_arch $dep_type "${dep_or#* }"); then
				info 1 "Build dependency ($dep_type) on '$dep_package' not for $ARCH"
				continue
			fi

			dep_tree="$dep_tree -> $dep_package ($dep_type)"

			if [ -z "$want_dep" ]; then
				if check_list skip "$dep_package"; then
					package_skipped="$package_skipped$dep_package$NL"
					continue
				elif [ "$dep_type" = C ] && \
				     [ -z "$with_vconflicts" ] && [ "$pkgdep" ]; then
					# Skip only unversioned conflicts
					continue
				fi
				print_dot_dependency $package "$OR_name" \
					$dep_package $dep_type "$pkgdep"
			elif [ "$dep_package" = "$want_dep" ]; then
				echo "$dep_tree"
				continue
			fi

			if check_list done "$dep_package" ||
			   ([ -z "$want_dep" ] &&
			    check_list end "$dep_package"); then
				:
			else
				# Recurse through dependencies, except for Suggests
				# and Conflicts
				case $dep_type in
				    S)
					if ! check_list done "$dep_package"; then
						debug 4 "Adding '$dep_package' ($dep_type) to ended"
						package_ended="$package_ended$NL$dep_package"
						package_leaf="$package_leaf$NL$dep_package"
					fi ;;
				    C)
					if ! check_list done "$dep_package"; then
						package_leaf="$package_leaf$NL$dep_package"
					fi ;;
				    *)
					if [ -z "$max_depth" ] || [ $level -lt $max_depth ]; then
						process_package $(($level + 1)) $dep_package \
							"$dep_tree" "$OR_name" ""
					else
						debug 4 "Adding '$dep_package' ($dep_type) to ended (max)"
						package_ended="$package_ended$NL$dep_package"
					fi ;;
				esac
			fi

			[ "$with_alternatives" ] || break
		done
	done
}

process_pseudo() {
	local level=$1
	local package=$2
	local providers=$3
	local dep_tree=$4
	local predep_OR_name=$5
	local ptype=$6
	local prior_OR_name p_package p_provider

	debug 3 "Getting providers for pseudo package '$package'"

	# For leaf packages we need to check if it was an alternative
	if [ "$ptype" = L ]; then
		predep_OR_name="$(get_prior_OR_name $package)"
	fi

	p_package="${predep_OR_name:+\"$predep_OR_name\":}\"$package\""

	# Print a dummy providing package if there are multiple; we could
	# possibly loop and display alternatives if there are not too many
	# alternative provides
	if echo "$providers" | grep -q ","; then
		echo -e "\t$p_package -> \"Pr-$package\" [dir=back,arrowtail=inv,color=green];"
		echo -e "\t\"Pr-$package\" [shape=point];"
	else
		provider=${providers%% *}

		prior_OR_name="$(get_prior_OR_name $provider)"
		p_provider="${prior_OR_name:+\"$prior_OR_name\":}\"$provider\""
		echo -e "\t$p_package -> $p_provider [dir=back,arrowtail=inv,color=green];"

		if check_list end "$provider" && \
		   [ -z "$prior_OR_name" ] && \
		   ! check_list done "$provider"; then
			debug 4 "Adding '$dep_package' (provides) to ended (list)"
			package_ended="$package_ended$NL$provider"
			package_done="$package_done$NL$provider"
		fi

		# Recurse to get dependencies for providing package
		dep_tree="$dep_tree <- $provider"
		if ! check_list done "$provider" && [ ! "$ptype" = L ]; then
			process_package $(($level + 1)) $provider "$dep_tree" "" ""
		fi
	fi

	# Green arrow sufficiently identifies pseudo package that is part of alternatives
	if [ -z "$predep_OR_name" ] || check_list OR_seen "$package"; then
		echo -e "\t\"$package\" [shape=octagon];"
	fi
}

process_missing() {
	local package=$1

	local prior_OR_name="$(get_prior_OR_name $package)"
	if [ -z "$prior_OR_name" ]; then
		echo -e "\t\"$package\" [style=filled,fillcolor=oldlace];"
	else
		package_unknown="$package_unknown$package$NL"
	fi
}

process_package() {
	local level=$1
	local package=$2
	local dep_tree="$3"
	local predep_OR_name="$4"
	local ptype="$5"
	local pinfo providers deps

	info 2 "Level $level: processing $package ${ptype:+($ptype)}"

	if [ "$ptype" != L ] && check_list ended $package; then
		debug 4 "Removing '$dep_package' from ended"
		package_ended="$(echo "$package_ended" | grep -v "^$package$")"
	fi

	RET=0
	if [ "$ptype" = S ]; then
		pinfo="$(grep_source $package)" || RET=$?
	else
		pinfo="$(grep_avail $package)" || RET=$?
	fi

	if [ "$ptype" = B ] || [ "$ptype" = S ]; then
		if [ $RET -eq 0 ]; then
			[ "$want_dep" ] || print_dot_header
		else
			error "no dependency info found for '$package'"
		fi
	else
		if [ -z "$want_dep" ] && [ $RET -ne 0 ]; then
			process_missing $package
		fi
	fi
	pinfo="$(prep_deps "$pinfo")"

	# Mark as done now to prevent recursion loops
	package_done="$package_done$NL$package"

	# Not sure if we should do this or not when showing dependency paths
	providers=$(get_deps "$pinfo" Provided-By)
	if [ -z "$want_dep" ] && [ "$providers" ]; then
		process_pseudo $level $package \
			"$providers" "$dep_tree" "$predep_OR_name" "$ptype"
	fi

	[ ! "$ptype" = L ] || return 0

	if [ "$ptype" = S ]; then
		deps=$(get_deps "$pinfo" Build-Depends)
		process_deps $level $package "$deps" B "" ""
		deps=$(get_deps "$pinfo" Build-Depends-Indep)
		process_deps $level $package "$deps" BI "" ""
	fi

	deps=$(get_deps "$pinfo" Pre-Depends)
	process_deps $level $package "$deps" PD "$dep_tree" "$predep_OR_name"

	deps=$(get_deps "$pinfo" Depends)
	process_deps $level $package "$deps" D "$dep_tree" "$predep_OR_name"

	if [ "$with_recommends" ]; then
		deps=$(get_deps "$pinfo" Recommends)
		process_deps $level $package "$deps" R "$dep_tree" "$predep_OR_name"
	fi

	if [ "$with_suggests" ]; then
		deps=$(get_deps "$pinfo" Suggests)
		process_deps $level $package "$deps" S "$dep_tree" "$predep_OR_name"
	fi

	if [ "$with_conflicts" ]; then
		deps=$(get_deps "$pinfo" Conflicts)
		process_deps $level $package "$deps" C "$dep_tree" "$predep_OR_name"
	fi

	# TODO (?)
	#provides=$(get_deps "$pinfo" Provides)
	#[ -z "$provides" ] || echo "$package provides: $provides" >&2

	if [ "$show_installed" ] && is_installed $package && \
	   [ -z "$(get_prior_OR_name $package)" ]; then
		mark_installed "$package"
	fi

	debug 3 "Level $level: processing $package ${ptype:+($ptype)} - done"
}

### MAINLINE ###

package_skip=""
package_skipped=""
package_end=""
package_ended=""
package_done=""
package_leaf=""
package_unknown=""
package_OR_seen=""
OR_cnt=0
OR_list=""

# Import lists to limit processing:
# - "skip" packages are completely ignored: nothing is displayed
# - "end" packages are displayed and marked as such, but we don't recurse
#   to determine their dependencies
if [ -z "$show_all" ]; then
	for file in ~/.debtree/skiplist /etc/debtree/skiplist; do
		if [ -r $file ]; then
			info 3 "Using list of 'skip' packages from $file"
			package_skip="$(import_list $file)"
			break
		fi
	done
	for file in ~/.debtree/endlist /etc/debtree/endlist; do
		if [ -r $file ]; then
			info 3 "Using list of 'end' packages from $file"
			package_end="$(import_list $file)"
			break
		fi
	done
fi
if [ "$no_skip" ] && [ "$package_skip" ]; then
	# Change skip packages to end packages
	package_end="${package_end:+$package_end$NL}$package_skip"
	package_skip=""
fi

# If a dependency path is asked for, check if the second package exists
if [ "$want_dep" ]; then
	if ! grep_avail $want_dep >/dev/null; then
		error "no dependency info found for '$want_dep'"
	fi
fi

# ptype B/S indicates "start" binary/source package
process_package 1 $requested_package $requested_package "" $ptype

# For packages we did not yet recurse through, check if they are pseudo packages
# as we want to show the providing package(s)
for dep_package in $package_leaf; do
	if ! check_list done "$dep_package"; then
		process_package - $dep_package "" "" L
	fi
done

if [ -z "$want_dep" ]; then
	# Print record definitions for alternatives
	IFS="$NL"
	for altrec in $OR_list; do
		IFS="$IFS_SV"
		print_alternatives "$altrec"
	done

	# Set shape to diamond for packages whose dependencies we did not
	# recurse into
	for package in $package_ended; do
		mark_endpackage $package
	done
fi

[ "$want_dep" ] || print_dot_footer

if [ "$package_skipped" ]; then
	info 1 "The following dependencies have been excluded from the graph (skipped):"
	info 1 $package_skipped
fi
