#! /bin/bash
set -e

# Usage: dep-tree [-s] <package name>
#        dep-tree [-s] <package name> <dependency>

# In first case script produces a dot file for processing with 'dot'.
# Examples: dep-tree <package> | dot -Tps | kghostview -
#           dep-tree <package> | dot -Tpng -o <package>.png
# In second case it will list the dependency path(s) from the first
# to the second package.
# With the -s option "Suggests" are included as well.

# TODO
# - process/display alternatives ("OR" relations)
# - distinguish meta/pseudo packages
# - automatically end on packages with a Provides:

# NOTES
# - Processing of suggests is limited to only one level; doing a full tree
#   would lead to insane trees for almost any package

with_suggests=""
with_recommends=1
with_conflicts=""
with_versions=1
do_rotate=""
do_condense=""

while true; do
	case "$1" in
	    "")
		break ;;
	    --no-recommends)
		with_recommends="" ;;
	    -S|--with-suggests)
		with_suggests=1 ;;
	    -C|--with-conflicts)
		with_conflicts=1 ;;
	    --no-versions)
		with_versions="" ;;
	    --rotate)
		do_rotate="1" ;;
	    --condense)
		do_condense="1" ;;
	    -*)
		echo "unrecognized argument '$1'"
		exit 1
		;;
	    *)
		if [ -z "$requested_package" ]; then
			requested_package=$1
		elif [ -z "$want_dep" ]; then
			want_dep=$1
		else
			echo "Error: invalid number of arguments"
			exit 1
		fi
		;;
	esac
	shift
done

# Don't allow Suggests without Recommends
[ "$with_recommends" ] || with_suggests=""

if [ -z "$requested_package" ]; then
	echo "Error: invalid number of arguments"
	exit 1
fi

package_done=","
package_skip=",libc6,libgcc1,libstdc++6,zlib1g,libx11-6,"
package_end=",debconf,defoma,procmail,gnupg,ucf,x11-common,xbase-clients,xutils,xfonts-base,perl,kdelibs4c2a,libarts1c2a,libkdepim1a,libqt-rnt,libqt3-mt,libfam0,libfontconfig1,dbus,libgtk2.0-0,gconf2,pythoni-minimal,python2.4,fontconfig,kdebase-kio-plugins,kdepim-kio-plugins,kdesktop,kcontrol,kaddressbook,"
IFS_SV="$IFS"

print_dot_header() {
	echo "digraph \"$requested_package\" {"
	[ "$do_rotate" ] || echo -e "\trankdir=LR;"
	[ -z "$do_condense" ] || echo -e "\tconcentrate=true;"
}
print_dot_footer() {
	echo "}"
}

print_dot() {
	local package=$1
	local package_dep=$2
	local dep_type=$3
	local verdep=$4
	local opts=""

	case $dep_type in
	    P)	opts="${opts:+$opts,}color=purple,style=bold" ;;
	    D)	opts="${opts:+$opts,}color=blue" ;;
	    R)	: ;;
	    S)	opts="${opts:+$opts,}style=dotted" ;;
	    C)	opts="${opts:+$opts,}color=red" ;;
	esac

	# Always include versions for versioned conflicts
	if [ "$verdep" ]; then
		if [ "$with_versions" ] || [ "$dep_type" = C ]; then
			opts="${opts:+$opts,}label=\"$verdep\""
		fi
	fi
	[ -z "opts" ] || opts=" [$opts]"

	# Would be nice to suppress double lines for such packages
	if echo "$package_end" | grep -q ",$package_dep," &&
	   ! echo "$package_done" | grep -q ",$package_dep,"; then
		echo -e "\t\"$package_dep\" [shape = octagon];"
		package_done="$package_done$package_dep,"
	fi

	echo -e "\t\"$package\" -> \"$package_dep\"$opts;"
}

grep_avail() {
	local pinfo
	local fields="Package,Pre-Depends,Depends,Recommends,Suggests,Provides,Conflicts"

	if ! pinfo="$(grep-available -XP $1 -s $fields)"; then
		pinfo="$(grep-aptavail -XP $1 -s $fields || true)"
	fi
	echo "$pinfo"
}

get_deps() {
	echo "$1" | grep "^$2:" | sed "s/^[^:]*: //"
}

# Convert dependency string a bit for easier parsing:
# - remove space after ","
# - remove space before and after "|"
# - add space after package name if not versioned
prep_deps() {
	echo "$@" | sed "s:, :,:g;s: | :|:g;s:\([^) ]\)\(,\||\|$\):\1 \2:g"
}

process_deps() {
	local package=$1
	local deps=$2
	local dep_type=$3
	local dep_tree_in=$4
	local IFS dep dep_or dep_package verdep
	local OR_cnt=0

	IFS=,
	for dep in $deps; do
		IFS="$IFS_SV"

		if echo $dep | grep -q "|"; then
			OR_cnt=$(($OR_cnt + 1))
		fi

		IFS="|"
		for dep_or in $dep; do
			IFS="$IFS_SV"
			local dep_tree=$dep_tree_in

			dep_package=${dep_or%% *}
			verdep=${dep_or#* }

			dep_tree="$dep_tree -> $dep_package ($dep_type)"

			if [ -z "$want_dep" ]; then
				if echo "$package_skip" | grep -q ",$dep_package,"; then
					continue
				fi
				print_dot $package $dep_package $dep_type "$verdep"
			elif [ "$dep_package" = "$want_dep" ]; then
				echo "$dep_tree"
				continue
			fi

			if echo "$package_done" | grep -q ",$dep_package," ||
			   ([ -z "$want_dep" ] &&
			    echo "$package_end" | grep -q ",$dep_package,"); then
				:
			else
				# Recurse through dependencies, except for Suggests
				# and conflicts
				case $dep_type in
				    S|C)
					: ;;
				    *)
					process_package $dep_package "$dep_tree" ;;
				esac
			fi

			# Skip alternatives for now (TODO)
			break
		done
	done
}

process_package() {
	local package=$1
	local dep_tree="$2"
	local pinfo deps 

	package_done="$package_done$package,"

	pinfo="$(prep_deps "$(grep_avail $package Pre-Depends)")"

	deps=$(get_deps "$pinfo" Pre-Depends)
	process_deps $package "$deps" P "$dep_tree"

	deps=$(get_deps "$pinfo" Depends)
	process_deps $package "$deps" D "$dep_tree"

	if [ "$with_recommends" ]; then
		deps=$(get_deps "$pinfo" Recommends)
		process_deps $package "$deps" R "$dep_tree"
	fi

	if [ "$with_suggests" ]; then
		deps=$(get_deps "$pinfo" Suggests)
		process_deps $package "$deps" S "$dep_tree"
	fi

	# Eventually the option to include Conflicts should be handled in
	# process_deps() as we want to include conflicts if they affect
	# alternative dependencies; example:
	# apt-cache dotty debconf: debconf-i18n vs. debconf-english
	#c=$(get_deps "$pinfo" Conflicts)
	#[ -z "$c" ] || echo "$package conflicts: $c" >&2
	if [ "$with_conflicts" ]; then
		deps=$(get_deps "$pinfo" Conflicts)
		process_deps $package "$deps" C "$dep_tree"
	fi

	#provides=$(get_deps "$pinfo" Provides)
	#[ -z "$provides" ] || echo "$package provides: $provides" >&2
}

## MAINLINE

[ "$want_dep" ] || print_dot_header

process_package $requested_package "$requested_package"

[ "$want_dep" ] || print_dot_footer
